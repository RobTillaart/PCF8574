\href{https://github.com/marketplace/actions/arduino_ci}{\texttt{ }} \href{https://github.com/RobTillaart/PCF8574/actions/workflows/arduino-lint.yml}{\texttt{ }} \href{https://github.com/RobTillaart/PCF8574/actions/workflows/jsoncheck.yml}{\texttt{ }} \href{https://github.com/RobTillaart/PCF8574/issues}{\texttt{ }}

\href{https://github.com/RobTillaart/PCF8574/blob/master/LICENSE}{\texttt{ }} \href{https://github.com/RobTillaart/PCF8574/releases}{\texttt{ }} \href{https://registry.platformio.org/libraries/robtillaart/PCF8574}{\texttt{ }}\hypertarget{md__r_e_a_d_m_e_autotoc_md31}{}\doxysection{PCF8574}\label{md__r_e_a_d_m_e_autotoc_md31}
Arduino library for \mbox{\hyperlink{class_p_c_f8574}{PCF8574}} -\/ 8 channel I2C IO expander.\hypertarget{md__r_e_a_d_m_e_autotoc_md32}{}\doxysubsection{Description}\label{md__r_e_a_d_m_e_autotoc_md32}
Related to the PCF8575 16 channel IO expander library \href{https://github.com/RobTillaart/PCF8575}{\texttt{ https\+://github.\+com/\+Rob\+Tillaart/\+PCF8575}}

This library gives easy control over the 8 pins of a \mbox{\hyperlink{class_p_c_f8574}{PCF8574}} and PCF8574A chip. These chips are identical in behaviour although there are two distinct address ranges.

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{3}{|X[-1]}|}
\hline
\cellcolor{\tableheadbgcolor}\textbf{ type   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ address-\/range   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ notes    }\\\cline{1-3}
\endfirsthead
\hline
\endfoot
\hline
\cellcolor{\tableheadbgcolor}\textbf{ type   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ address-\/range   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ notes    }\\\cline{1-3}
\endhead
\mbox{\hyperlink{class_p_c_f8574}{PCF8574}}   &\PBS\centering 0x20 to 0x27   &\PBS\centering same range as PCF8575 !   \\\cline{1-3}
\end{longtabu}
$\vert$ PCF8574A $\vert$ 0x38 to 0x3F $\vert$

So you can connect up to 16 \mbox{\hyperlink{class_p_c_f8574}{PCF8574}} on one I2C bus, giving access to 16 x 8 = 128 IO lines. To maximize IO lines combine 8 x PCF8575 + 8 x PCF8574A giving 128 + 64 = 192 IO lines. Be sure to have a well dimensioned power supply.

The library allows to read and write both single pins or 8 pins at once. Furthermore some additional functions are implemented that are playful and useful.\hypertarget{md__r_e_a_d_m_e_autotoc_md33}{}\doxyparagraph{Interrupts intro}\label{md__r_e_a_d_m_e_autotoc_md33}
The \mbox{\hyperlink{class_p_c_f8574}{PCF8574}} has an interrupt output line (INT) to notify an MCU that one of the input lines has changed. This can be used to prevent active polling of the \mbox{\hyperlink{class_p_c_f8574}{PCF8574}}, which can be more efficient.

From the datasheet\+:

{\itshape An interrupt is generated by any rising or falling edge of the port inputs in the input mode. After time, (Tiv), INT is valid. Resetting and reactivating the interrupt circuit is achieved when data on the port is {\bfseries{changed to the original setting}} or data is {\bfseries{read from}}, or {\bfseries{written to}}, the port that generated the interrupt. Resetting occurs in the read mode at the acknowledge bit after the rising edge of the SCL signal, or in the write mode at the acknowledge bit after the high-\/to-\/low transition of the SCL signal.}

So there are three scenarios how the INT is reset.


\begin{DoxyEnumerate}
\item pins revert to original state (lesser known).
\item read from the device (well known)
\item write to the device (well known)
\end{DoxyEnumerate}

This implies that polling the \mbox{\hyperlink{class_p_c_f8574}{PCF8574}} can miss an INT in scenario 1. (see \#48) In practice if you have faster polling than your signals changes this would not be a problem. E.\+g. tactile switches and a polling frequency $>$ 100 Hz will work.\hypertarget{md__r_e_a_d_m_e_autotoc_md34}{}\doxyparagraph{Interrupts library}\label{md__r_e_a_d_m_e_autotoc_md34}
The library cannot handle the \mbox{\hyperlink{class_p_c_f8574}{PCF8574}} interrupts as it has no code for it. The user should catch the interrupt in his own code to set a flag and can use the library to see which line has changed.

There are two examples to show how interrupts can be handled\+:


\begin{DoxyItemize}
\item {\bfseries{PCF8574\+\_\+interrupt.\+ino}}
\item {\bfseries{PCF8574\+\_\+rotary\+Encoder.\+ino}}
\end{DoxyItemize}

A more advanced interrupt handler would not set a boolean flag in the interrupt routine but increase a counter (uint8\+\_\+t or larger). Then it would be possible to see that\+:


\begin{DoxyEnumerate}
\item an interrupt occurred. (counter $>$ 0)
\item if one or more interrupts are not handled (counter $>$ 1)
\end{DoxyEnumerate}

A minimal example that shows catching missed interrupts\+:


\begin{DoxyItemize}
\item {\bfseries{PCF8574\+\_\+interrupt\+\_\+advanced.\+ino}}
\end{DoxyItemize}\hypertarget{md__r_e_a_d_m_e_autotoc_md35}{}\doxyparagraph{0.\+4.\+0 Breaking change}\label{md__r_e_a_d_m_e_autotoc_md35}
Version 0.\+4.\+0 introduced a breaking change. You cannot set the pins in {\bfseries{begin()}} any more. This reduces the dependency of processor dependent Wire implementations. The user has to call {\bfseries{Wire.\+begin()}} and can optionally set the Wire pins before calling {\bfseries{begin()}}.\hypertarget{md__r_e_a_d_m_e_autotoc_md36}{}\doxyparagraph{Related}\label{md__r_e_a_d_m_e_autotoc_md36}
16 bit port expanders


\begin{DoxyItemize}
\item \href{https://github.com/RobTillaart/MCP23017_RT}{\texttt{ https\+://github.\+com/\+Rob\+Tillaart/\+MCP23017\+\_\+\+RT}}
\item \href{https://github.com/RobTillaart/MCP23S17}{\texttt{ https\+://github.\+com/\+Rob\+Tillaart/\+MCP23\+S17}}
\item \href{https://github.com/RobTillaart/PCF8575}{\texttt{ https\+://github.\+com/\+Rob\+Tillaart/\+PCF8575}}
\end{DoxyItemize}

8 bit port expanders


\begin{DoxyItemize}
\item \href{https://github.com/RobTillaart/MCP23008}{\texttt{ https\+://github.\+com/\+Rob\+Tillaart/\+MCP23008}}
\item \href{https://github.com/RobTillaart/MCP23S08}{\texttt{ https\+://github.\+com/\+Rob\+Tillaart/\+MCP23\+S08}}
\item \href{https://github.com/RobTillaart/PCF8574}{\texttt{ https\+://github.\+com/\+Rob\+Tillaart/\+PCF8574}}
\end{DoxyItemize}\hypertarget{md__r_e_a_d_m_e_autotoc_md37}{}\doxysubsection{I2\+C Clock}\label{md__r_e_a_d_m_e_autotoc_md37}
Tested on UNO with {\bfseries{PCF8574\+\_\+performance}} showed that the \mbox{\hyperlink{class_p_c_f8574}{PCF8574}} still works at 500 KHz and failed at 600 KHz. These values are outside the specs of the datasheet so they are not recommended. However when performance is needed you can try to overclock the chip.

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{4}{|X[-1]}|}
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ clock speed   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Read   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Write   }&\cellcolor{\tableheadbgcolor}\textbf{ Notes    }\\\cline{1-4}
\endfirsthead
\hline
\endfoot
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ clock speed   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Read   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Write   }&\cellcolor{\tableheadbgcolor}\textbf{ Notes    }\\\cline{1-4}
\endhead
\PBS\centering 100000   &\PBS\centering 236   &\PBS\centering 240   &spec datasheet   \\\cline{1-4}
\end{longtabu}
$\vert$ 200000 $\vert$ 132 $\vert$ 140 $\vert$ $\vert$ 300000 $\vert$ 104 $\vert$ 108 $\vert$ $\vert$ 400000 $\vert$ 96 $\vert$ 96 $\vert$ max advised speed $\vert$ $\vert$ 500000 $\vert$ 92 $\vert$ 92 $\vert$ not recommended $\vert$ $\vert$ 600000 $\vert$ crash $\vert$ crash $\vert$\hypertarget{md__r_e_a_d_m_e_autotoc_md38}{}\doxysubsection{Interface}\label{md__r_e_a_d_m_e_autotoc_md38}

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#include "{}PCF8574.h"{}}}

\end{DoxyCode}


{\bfseries{PCF8574\+\_\+\+INITIAL\+\_\+\+VALUE}} is a define 0x\+FF that can be set compile time or before the include of \char`\"{}pcf8574.\+h\char`\"{} to overrule the default value used with the {\bfseries{begin()}} call.\hypertarget{md__r_e_a_d_m_e_autotoc_md39}{}\doxyparagraph{Constructor}\label{md__r_e_a_d_m_e_autotoc_md39}

\begin{DoxyItemize}
\item {\bfseries{\mbox{\hyperlink{class_p_c_f8574}{PCF8574}}(uint8\+\_\+t device\+Address = 0x20, Two\+Wire $\ast$wire = \&Wire)}} Constructor with optional address, default 0x20, and the optional Wire interface as parameter.
\item {\bfseries{bool begin(uint8\+\_\+t value = PCF8574\+\_\+\+INITIAL\+\_\+\+VALUE)}} set the initial value (default 0x\+FF) for the pins and masks.
\item {\bfseries{bool is\+Connected()}} checks if the address set in the constructor or by {\bfseries{set\+Address()}} is visible on the I2C bus.
\item {\bfseries{bool set\+Address(const uint8\+\_\+t device\+Address)}} sets the device address after construction. Can be used to switch between \mbox{\hyperlink{class_p_c_f8574}{PCF8574}} modules runtime. Note this corrupts internal buffered values, so one might need to call {\bfseries{read8()}} and/or {\bfseries{write8()}}. Returns true if address can be found on I2C bus.
\item {\bfseries{uint8\+\_\+t get\+Address()}} Returns the device address.
\end{DoxyItemize}\hypertarget{md__r_e_a_d_m_e_autotoc_md40}{}\doxyparagraph{Read and Write}\label{md__r_e_a_d_m_e_autotoc_md40}

\begin{DoxyItemize}
\item {\bfseries{uint8\+\_\+t read8()}} reads all 8 pins at once. This one does the actual reading.
\item {\bfseries{uint8\+\_\+t read(uint8\+\_\+t pin)}} reads a single pin; pin = 0..7
\item {\bfseries{uint8\+\_\+t value()}} returns the last read inputs again, as this information is buffered in the class this is faster than reread the pins.
\item {\bfseries{void write8(const uint8\+\_\+t value)}} writes all 8 pins at once. This one does the actual writing.
\item {\bfseries{uint8\+\_\+t write(const uint8\+\_\+t pin, const uint8\+\_\+t value)}} writes a single pin; pin = 0..7; value is HIGH(1) or LOW (0)
\item {\bfseries{uint8\+\_\+t value\+Out()}} returns the last written data.
\end{DoxyItemize}\hypertarget{md__r_e_a_d_m_e_autotoc_md41}{}\doxyparagraph{Button}\label{md__r_e_a_d_m_e_autotoc_md41}
The $\ast$$\ast$\char`\"{}button\char`\"{}$\ast$$\ast$ functions are to be used when you mix input and output on one IC. It does not change / affect the pins used for output by masking these. Typical usage is to call {\bfseries{set\+Button\+Mask()}} once in setup as pins do not (often) change during program execution.


\begin{DoxyItemize}
\item {\bfseries{void set\+Button\+Mask(const uint8\+\_\+t mask)}} sets the (bit) mask which lines are input.
\item {\bfseries{uint8\+\_\+t get\+Button\+Mask()}} returns the set button\+Mask.
\item {\bfseries{uint8\+\_\+t read\+Button8()}} use the mask set by set\+Button\+Mask to select specific input pins.
\item {\bfseries{uint8\+\_\+t read\+Button8(const uint8\+\_\+t mask)}} use a specific mask to select specific input pins. Note this can be a subset of the pins set with {\bfseries{set\+Button\+Mask()}} if one wants to process not all.
\item {\bfseries{uint8\+\_\+t read\+Button(const uint8\+\_\+t pin)}} read a single input pin.
\end{DoxyItemize}

Background -\/ \href{https://github.com/RobTillaart/Arduino/issues/38}{\texttt{ https\+://github.\+com/\+Rob\+Tillaart/\+Arduino/issues/38}}\hypertarget{md__r_e_a_d_m_e_autotoc_md42}{}\doxyparagraph{Special}\label{md__r_e_a_d_m_e_autotoc_md42}

\begin{DoxyItemize}
\item {\bfseries{void toggle(const uint8\+\_\+t pin)}} toggles a single pin
\item {\bfseries{void toggle\+Mask(const uint8\+\_\+t mask = 0x\+FF)}} toggles a selection of pins, if you want to invert all pins use 0x\+FF (default value).
\item {\bfseries{void shift\+Right(const uint8\+\_\+t n = 1)}} shifts output channels n pins (default 1) pins right (e.\+g. LEDs ). Fills the higher lines with zero\textquotesingle{}s.
\item {\bfseries{void shift\+Left(const uint8\+\_\+t n = 1)}} shifts output channels n pins (default 1) pins left (e.\+g. LEDs ). Fills the lower lines with zero\textquotesingle{}s.
\item {\bfseries{void rotate\+Right(const uint8\+\_\+t n = 1)}} rotates output channels to right, moving lowest line to highest line.
\item {\bfseries{void rotate\+Left(const uint8\+\_\+t n = 1)}} rotates output channels to left, moving highest line to lowest line.
\item {\bfseries{void reverse()}} reverse the \char`\"{}bit pattern\char`\"{} of the lines, swapping pin 7 with 0, 6 with 1, 5 with 2 etc.
\end{DoxyItemize}\hypertarget{md__r_e_a_d_m_e_autotoc_md43}{}\doxyparagraph{Select}\label{md__r_e_a_d_m_e_autotoc_md43}
Some convenience wrappers.


\begin{DoxyItemize}
\item {\bfseries{void select(const uint8\+\_\+t pin)}} sets a single pin to HIGH, all others are set to LOW. If pin $>$ 7 all pins are set to LOW. Can be used to select one of n devices.
\item {\bfseries{void select\+N(const uint8\+\_\+t pin)}} sets pins 0..pin to HIGH, all others are set to LOW. If pin $>$ 7 all pins are set to LOW. This can typical be used to implement a VU meter.
\item {\bfseries{void select\+None()}} sets all pins to LOW.
\item {\bfseries{void select\+All()}} sets all pins to HIGH.
\end{DoxyItemize}\hypertarget{md__r_e_a_d_m_e_autotoc_md44}{}\doxyparagraph{Miscellaneous}\label{md__r_e_a_d_m_e_autotoc_md44}

\begin{DoxyItemize}
\item {\bfseries{int last\+Error()}} returns the last error from the lib. (see .h file).
\end{DoxyItemize}\hypertarget{md__r_e_a_d_m_e_autotoc_md45}{}\doxysubsection{Error codes}\label{md__r_e_a_d_m_e_autotoc_md45}
\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{3}{|X[-1]}|}
\hline
\cellcolor{\tableheadbgcolor}\textbf{ name   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ value   }&\cellcolor{\tableheadbgcolor}\textbf{ description    }\\\cline{1-3}
\endfirsthead
\hline
\endfoot
\hline
\cellcolor{\tableheadbgcolor}\textbf{ name   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ value   }&\cellcolor{\tableheadbgcolor}\textbf{ description    }\\\cline{1-3}
\endhead
PCF8574\+\_\+\+OK   &\PBS\centering 0x00   &no error    \\\cline{1-3}
PCF8574\+\_\+\+PIN\+\_\+\+ERROR   &\PBS\centering 0x81   &pin number out of range    \\\cline{1-3}
PCF8574\+\_\+\+I2\+C\+\_\+\+ERROR   &\PBS\centering 0x82   &I2C communication error   \\\cline{1-3}
\end{longtabu}
\hypertarget{md__r_e_a_d_m_e_autotoc_md46}{}\doxysubsection{Operation}\label{md__r_e_a_d_m_e_autotoc_md46}
See examples.

It is advised to use pull-\/up or pull-\/down resistors so the lines have a defined state at startup.\hypertarget{md__r_e_a_d_m_e_autotoc_md47}{}\doxysubsection{Future}\label{md__r_e_a_d_m_e_autotoc_md47}
\hypertarget{md__r_e_a_d_m_e_autotoc_md48}{}\doxyparagraph{Must}\label{md__r_e_a_d_m_e_autotoc_md48}

\begin{DoxyItemize}
\item update documentation.
\item keep in sync with PCF8575 (as far as meaningful)
\end{DoxyItemize}\hypertarget{md__r_e_a_d_m_e_autotoc_md49}{}\doxyparagraph{Should}\label{md__r_e_a_d_m_e_autotoc_md49}
\hypertarget{md__r_e_a_d_m_e_autotoc_md50}{}\doxyparagraph{Could}\label{md__r_e_a_d_m_e_autotoc_md50}

\begin{DoxyItemize}
\item move code to .cpp
\end{DoxyItemize}\hypertarget{md__r_e_a_d_m_e_autotoc_md51}{}\doxyparagraph{Wont}\label{md__r_e_a_d_m_e_autotoc_md51}
\hypertarget{md__r_e_a_d_m_e_autotoc_md52}{}\doxysubsection{Support}\label{md__r_e_a_d_m_e_autotoc_md52}
If you appreciate my libraries, you can support the development and maintenance. Improve the quality of the libraries by providing issues and Pull Requests, or donate through Pay\+Pal or Git\+Hub sponsors.

Thank you, 